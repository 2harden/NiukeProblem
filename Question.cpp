// 牛客网刷题
#include <iostream>
#include <string.h>
using namespace std;

// 编译运行：g++ .\Question.cpp -o .\Question.exe;.\Question.exe

// 1,================================================================
// int fun(void) {
//     int *p, j, i=10;
//     p = &j;
//     *p = i++;
//     i += sizeof(i) + sizeof(*p) + sizeof(p);
//     return i;
// }

// int main()
// {
//     cout << fun() << endl; // 32位系统输出23 64位系统输出为27

//     return 0;
// }

// 2,================================================================
// int main()
// {
//     char ccString1[]="Is Page Fault??";
//     char ccString2[]="No Page Fault??";
//     strcpy(ccString1,"No"); // 执行strcpy(ccString1,"No"); ，ccString1变为"No\0Page Fault??"，会将字符串的结束符'\0'放入，所以比较时返回false，执行cout << ccString1; 输出时遇到结束符'\0'就结束，只输出“NO”
//     if(strcmp(ccString1,ccString2)==0)
//         cout<<ccString2;
//     else
//         cout<<ccString1;

//     return 0;
// }

// 3,================================================================
// int main() {
//     int a = 1;
//     int b = 2;
//     for (; a < 8; a++) {
//         b += a;
//         a += 2;
//     }
//     printf("%d, %d\n", a, b); // 10, 14 a++不要忘记

//     return 0;
// }

// 4,================================================================
// int main() {
//     int i = 5;
//     int a = (++i)--;
//     cout << "a = " << a << "\t" << "i = " << i << endl; // a = 6   i = 5

//     return 0;
// }

// 5,================================================================
// sizeof()与strlen()
// int main()
// {
// 	char *s = "a+b=20\n";
// 	cout << sizeof(s) << '\n'; // 8 \n的算一个字符，占用两个空间
// 	cout << strlen(s); // 7 \n转意为换行符，所以长度是7

//     return 0;
// } 

// 6,================================================================
// int main()
// {
//     int a[4] = { 0 };
//     for(int i=0;i<4;++i){
//         if(i&1){
//             a[i]=1;
//         }
//         cout << a[i] << "  "; // 0 1 0 1 位运算 0&1=0 1&1=1 2&1=0x10&0x01=0 3&1=0x11&0x01=0x11
//     }

//     return 0;
// }

// 7,================================================================
// 字节对齐
// 对于第一条原则，每个变量相对于结构体的首地址的偏移量必须是对齐参数的整数倍，这句话中的对齐参数是取每个变量自身对齐参数和系统默认对齐参数#pragma pack(n)中较小的一个;
// 对于第二条原则，结构体变量所占空间的大小是对齐参数的整数倍。这句话中的对齐参数有点复杂，它是取结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数。
// #pragma pack(2) // 强制2字节对齐
// class A
// {
//     int i;                          // 占4个字节
//     union U                         // union是共享内存空间的，并且union所占的字节数由里面最大元素决定！因此char buff[13]和int i共享内存空间，由于2字节对齐，因此13+1，共占14个字节
//     {
//         char buff[13];
//         int i;
//     }u;
//     void foo(){}                    // 成员函数不占内存空间
//     typedef char* (*f)(void*);      // typedef是类型别名也不占内存空间，如果typedef去掉 就是一个指针 这个时候就要占内存空间 32位机器是4字节，64位机器是8字节
//     enum{red, green, blue} color;   // 对于enum，规定其占一个int的大小，4个字节
// }a;

// int main()
// {
//     cout << sizeof(a) << endl;

//     return 0;
// }

// 8,================================================================
// 以下程序存在什么问题？ 
// 数组下标越界
// 死循环
// #define MAX 255 
// int main()
// {
//     unsigned char a[MAX],i; // 这个应该是的问题，数组255大小，但是当a[255]就是256个元素，相当于越界了
//     for(i=0;i<=MAX;i++)     // 这个就是字符型的变量大小在0-255之间，所以说i永远不可能大于255的，死循环
                               // 原因在于unsigned char 这个数据类型，它占了 8位，表示范围是 0~255（00000000~11111111，八位）； 当改成256后，虽说看似数组下标没越界，但是当i=255; i++ ；因为 i本身是unsigned char类型，占8位，所以此时i+1变成了100000000 9位，又因为i只能占8位，所以舍掉了最高位，此时的i值又变成00000000了，即就是0；然后就成了死循环了。。。
//     a[i]=i;
// }

// 9,================================================================
// ++与--运算符
int main()
{
    int x = 1, y = -1;
    // 按位&：位和位相与，数据同为1，则为1，否则为0
    // 按位 |：位和位相或，数据同为0，则为0，否则为1
    // x值为1，x--值为0
    // y值为-1；y++值为0
    // 0&0为0
    printf("%d\n", (x-- & ++y)); // 后缀x--，先使用1，再将x-1 前缀++y，现将y+1，再使用y；

    return 0;
}